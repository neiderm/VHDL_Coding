----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 11/01/2023 06:52:41 AM
-- Design Name: 
-- Module Name: vdc - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity vdc is
    GENERIC (
        constant IMG_OFFSET : in integer := 0;
        constant VGA_COLS : in integer := 640;
        constant VGA_ROWS : in integer := 480;
        constant HCHAR_TOTAL : in integer := 80;
        constant VCHAR_TOTAL : in integer := 60
    );
    Port ( pclk : in STD_LOGIC;
           reset : in STD_LOGIC;
           address_in : in std_logic_vector(13 downto 0);
           data_in : in std_logic_vector(7 downto 0);
           vram_wr_en : in std_logic;
           hsync : out STD_LOGIC;
           vsync : out STD_LOGIC;
           rgb : out STD_LOGIC_VECTOR (11 downto 0);
           disp_ena : out STD_LOGIC
           );
end vdc;

architecture Behavioral of vdc is
    signal reset_l : std_logic;

    signal disp_ena_p0 : std_logic;
    signal disp_ena_p1 : std_logic;
    signal disp_ena_p2 : std_logic;
    signal disp_ena_p3 : std_logic;
    signal disp_ena_p4 : std_logic;
    signal hsync_p0 : std_logic;
    signal hsync_p1 : std_logic;
    signal hsync_p2 : std_logic;
    signal hsync_p3 : std_logic;
    signal hsync_p4 : std_logic;
    signal vsync_p0 : std_logic;

    signal pixel_x : integer;
    signal pixel_y : integer;

    signal char_raddr : std_logic_vector(3 downto 0); -- character row address
    signal vram_addr : std_logic_vector(13 downto 0);

    signal vram_charcode: std_logic_vector(7 downto 0);
    signal rom_addr : std_logic_vector(8 downto 0);
    signal chargen_rdata : std_logic_vector(7 downto 0);

    signal vram_dout_tmp : std_logic_vector(15 downto 0);
    signal vram_din_tmp : std_logic_vector(15 downto 0);

    signal pixel_bit : std_logic; -- bit output from mux
    signal pix_col_select : std_logic_vector(2 downto 0);
    signal pix_col_select_p0 : std_logic_vector(2 downto 0);
    signal pix_col_select_p1 : std_logic_vector(2 downto 0);
    signal pix_col_select_p2 : std_logic_vector(2 downto 0);
begin
    --------------------------------------------------
    --  inputs
    --------------------------------------------------
    reset_l <= not reset;

    --------------------------------------------------
    --  VGA sync generator
    --------------------------------------------------
    u_vga_control : entity work.vga_controller
        GENERIC map (
            h_pulse  => 96,
            h_bp     => 46,
            h_pixels => VGA_COLS,
            h_fp     => 16,
            h_pol    => '0',
            v_pulse  => 2,
            v_bp     => 33,
            v_pixels => VGA_ROWS,
            v_fp     => 10,
            v_pol    => '0')
        port map(
            pixel_clk => pclk, -- 25 Mhz
            reset_n  => reset_l, 
            h_sync   => hsync_p0,
            v_sync   => vsync_p0,
            disp_ena => disp_ena_p0,
            column  => pixel_x,
            row     => pixel_y,
            n_blank => open,
            n_sync  => open
        );

    --------------------------------------------------
    -- video RAM address generator
    --------------------------------------------------
    u_vram_addr : entity work.vram_addresser
    generic map(
        IMG_OFFSET => 0 -- 218 --set this to header size if generated from .BMP image
--        ADDR_BITS => C_VRAM_ADDR_BITS
    )
    port map(
        pix_clk => pclk,
        pix_x => pixel_x,
        pix_y => pixel_y,
        vr_address => vram_addr,
        row_address => char_raddr
        );

--    --------------------------------------------------
--    -- VRAM (generated by hex2rom)
--    --------------------------------------------------
--    u_char_vram: entity work.char_vram
--    port map(
--        Clk => pclk,
--        A => vram_addr,
--        D => vram_charcode
--    );

    --------------------------------------------------
    -- Dual-Port RAM with One Enable Controlling Both Ports
    -- Download: ftp://ftp.xilinx.com/pub/documentation/misc/xstug_examples.zip
    -- File: HDL_Coding_Techniques/rams/rams_13.vhd
    --------------------------------------------------
    u_char_vram_dp: entity work.rams_13
    port map(
        clk => pclk,
        en => '1',
        we => vram_wr_en,
        addra => address_in(6 downto 0), -- CPU address bus
        addrb => vram_addr(6 downto 0), -- video system address bus
        di => vram_din_tmp, -- data in, only from CPU data bus
        doa => open,
        dob => vram_dout_tmp -- data out to video system
    );
    -- convert RAM data width to system data bus width
    vram_din_tmp(7 downto 0) <= data_in;
    vram_charcode <= vram_dout_tmp(7 downto 0);

    --------------------------------------------------
    -- character generator ROM address decoder
    --  ROM address = character_code * font_height + scan_row % font_height
    --------------------------------------------------
    -- 64 x 8 x 8-bit-fontheight:
    rom_addr(8 downto 3) <= vram_charcode(5 downto 0); --  character_code * font_height
    rom_addr(2 downto 0) <= char_raddr(2 downto 0);    --  scan_row % font_height

    --------------------------------------------------
    -- character generator ROM
    --------------------------------------------------
    u_char_gen_rom: entity work.charg_rom
    port map(
        Clk => pclk,
        A => rom_addr,
        D => chargen_rdata -- 1 row of character tile pixels
    );

    --------------------------------------------------
    -- synchronize signals
    --------------------------------------------------
    process (pclk)
    begin
        if rising_edge(pclk) then
            -- synchronize pixel selection to font row data
            pix_col_select_p0 <= std_logic_vector(to_unsigned(pixel_x, pix_col_select'length));
            pix_col_select_p1 <= pix_col_select_p0;
            pix_col_select_p2 <= pix_col_select_p1;
            pix_col_select <= pix_col_select_p2;
            -- synchronize syncs
            hsync_p1 <= hsync_p0;
            hsync_p2 <= hsync_p1;
            hsync_p3 <= hsync_p2;
            hsync_p4 <= hsync_p3;

            disp_ena_p1 <= disp_ena_p0;
            disp_ena_p2 <= disp_ena_p1;
            disp_ena_p3 <= disp_ena_p2;
            disp_ena_p4 <= disp_ena_p3;
        end if;
    end process;

    --------------------------------------------------
    -- pixel output
    --------------------------------------------------
    -- "shift" the pixel of the current scan column out of the character row data
    u_char_pix_mux: entity work.multiplexers_1
    port map(
        di => chargen_rdata,
        sel => pix_col_select,
        do => pixel_bit
    );

    --------------------------------------------------
    -- drive output signals
    --------------------------------------------------
    disp_ena <= disp_ena_p4;
    hsync <= hsync_p4;
    vsync <= vsync_p0;
    rgb <= (others => pixel_bit); -- set pixel RGB all white (or all black)

end Behavioral;
